To get started, you must do:

  make extraction (run make extract-nob if you want to extract without first attempting
                   to build the Coq files in the Model directory)
  make

This directory contains a fuzzer for x86 byte code. The extracted code,
Fuzz.ml, takes parsers, as defined in Decode.v or elsewhere, and generates
byte code that is in the language recognized by these parsers.

The file fuzzgen.ml is a driver script for this. It emits the ascii
for the hex code corresponding to the generated byte code. It pads these
instructions with NOPS in between (this is used by filter.c - see that for 
details)

The script ./fuzzer.sh glues everything together. Here's what it does
- Calls fuzzgen.ml and dumps the result in fuzz.ascii
- Calls xxd -r -p on fuzz.ascii to produce fuzz.hex (xxd -r -p takes
  ascii values for hex and converts it into the corresponding binary)
- Then runs ld on fuzz.hex to produce fuzz.obj - the result is an elf
  file that defines symbols called _binary_fuzz_hex_start/end/size. 
- Runs gcc on filter.c, linking it with the fuzz.obj file to produce filter.out
- Runs filter.out. Filter.out remits the ascii corresponding to fuzz.ascii
  with instructions that triggered segfaults stripped out (to the best
  of its ability)
- Repeat the above process of xxd and ld on the output of filter.out
- Runs gcc on test.c, linking it with this fuzz.obj file, to produce
  test.out

The behavior of filter.c is a little subtle and is documented in the source for
it. test.c is a little C program that has a declared external function pointer
_binary_fuzz_hex_start. All it does in main() is just call this function
pointer. Which, after linking with fuzz.obj, will be the generated code we want
to run!

The result is test.out, which you can trace using ./run.sh. You will want to
stop at the symbol "_binary_fuzz_hex_end". Then you can load the emitted
mem0.txt, regs0.txt, mem1.txt trace files using the simulator as described in
../semantics_test/
